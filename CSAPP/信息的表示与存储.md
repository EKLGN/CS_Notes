[TOC]
## 信息的存储
现代计算机存储和处理的一切信息都是二值信号(0、1序列)，序列中的每一个0或1的叫做一个比特.信息仅仅是计算机中的0、1序列以某种方式进行解释的结果，即：信息=位+上下文。

### 虚拟内存
现代计算机存储器将一个字节作为最小的可寻址的内存单位。机器级程序将计算机的内存（包括CMOS，显卡等上的空间）抽象为一个庞大的字节数组，数组中存放01序列，各种信息没有本质区别，仅仅是在访问或处理数据时以某种方式将其进行解释，得到我们想要的信息。

例如，程序对象（程序中的数据，变量，指令），在内存中都是0、1序列，但是编译器维护着程序对象的类型信息，访问时将比特串解释为改类型的信息。

二进制串
$$01000001$$
如果为解释为ASICC码，就是‘A'；解释为无符号数就是65.

将虚拟内存看做字节数组意味着访问数据必须给出数据在字节数组中的下标，这个下标就叫做**虚拟地址**,虚拟地址的集合叫做**虚拟地址空间**.编程语言中的"指针"指的就算是虚拟地址或存储虚拟地址的变量.

### 进制
日常生活中人们使用多种进制,一切信息都是二进制的比特串,但是二进制数据不利于程序员的理解,因此人们将二进制数据转化为十六进制数据,在C语言中十六进制数据以0x开头,八进制数据以0开头.在此,我们不讲数字系统的内容,仅仅是给出一两个有用的结论.
1. 当$x=2^n$时,其二进制位级表示为1后面跟n个0.
2. 当$n=i+4j,且0\le i \le 3$时,由于一个十六进制的0相当于四个十进制的0,且$2^i$恰好可以用一个十六进制数字表示,因此二进制$2^n$可以表示为一个十六进制的$2^i$后面跟着$j$个0.

### 字
处理器一次能够处理的最大数据长度成为一个字,字也往往是处理器内部寄存器所能存储的数据最大长度、地址总线、数据总线宽度.因此,字长往往决定了处理器所能访问的虚拟地址空间的最大大小.

由于历史原因,字的概念说法不不一,作为衡量处理器性能的标志时,有16位字,32位字,64位字的说法;当作为数据大小单位时往往将一个字定义为16个字节.
* 在8086CPU中地址总线是20位,而字长为16位,因此上文使用"往往"一次.
* 在8086CUP中字为16位,这个概念也就一直保留了下来,往往将32为成为"双字"(double word).

机器的字长对计算机有重大影响,主要体现在三个方面:
1. 最大内存空间:
* 对于字长(指地址总线宽度)为$\omega$的机器,能偶访问的虚拟地址空间最大为$2^\omega-1bytes$.对于32位机,最大虚拟地址空间为$2^{32}-1$字节,约为4G,而对于64位机,最大则为$2^{64}-1$字节,其中的差距不言而喻.
2. 处理器一次能处理的最大数据宽度
* CPU在一次最多能存取、处理一个字的数据,字长会直接影响处理器处理数据的方式和性能.还会影响字节对齐,后续再谈.
3. 数据类型的大小
* 最大的影响是对指针类型的影响,指针就是虚拟地址,虚拟地址总是一个字长,因此指针类型也是一个字长.例如,32位机上,指针类型大小为32bytes,而在64位机上为64个字节.整形数据也会受到影响.

### 寻址(图,未完待续)
在字节宿主中肯定有些数据对象会跨越*多个字节*,为了访问它们,必须事先确定如何表示它们的地址和如何在内存中排列它们的规则.

几乎所有机器上,跨越多个字节的数据都被存储在连续的空间中,数据的地址是连续空间的**最小地址**.

然而,在如何排列上,却并不同意,有两种不分高低优略的做法,分别成为大端法和小端法.

**大端法**
最低有效字节在最前面.

**小端法**
最高有效字节在最前面.
///////[]()
确定机器是大端法机器还是小端法机器非常重要,这会直接影响数据的存放,影响我们查看内存中的数据和计算机间的通信.
我们后续会注意到这一点的重要性.

### 字符串
字符有多种编码方式,比如UTF-8,GB2312,ASICC等,其中最常用的是ASICC码,这也是C语言和绝大多数计算机默认的字符编码.下文中的"字符"默认指ASICC码.

与整形数据不同,字符并不跨越多个字节,因此在内存中,字符按在字符串中出现的顺序在从低字节到高字节存放.由此可见,文本数据相比二进制数据有更强的平台独立性.

## 数据的位级运算.
计算机中的数据都是二进制比特串,可以对它们的进行按位或、按位与、左移右移等运算.
### 按位运算
C元支持按位与、按位或、按位异或、按位取反等运算，运算符分别为& / | ^ ~.

按位运算脱胎于命题逻辑中析取合取等概念,具体运算方法不再赘述.仅结合案例说明怎样用.

### 移位
移位运算分为左移和右移.以下面的位串说明移动k位的做法.
$$[x_\omega,x_{\omega-1},x_k,...,x_0]$$
**左移**
* 丢弃最高的k位,右端补k个0.

**右移**
右移分为算术右移和逻辑右移.
* *算术右移*:在左端补k个0,丢弃低k为.
* *逻辑右移*:在左端补k个最高有效位的值,丢弃低k为.

以上运算的结果分别为:
$$[x_\omega,x_{\omega-1},...,x_k, \begin{matrix}k \\ \overbrace {0,...0} \end{matrix}]$$
C语言提供了左移运算符<<和右移运算符用以支持移位运算.