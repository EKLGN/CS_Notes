# 链表笔记
## 单链表:遍历、查找、插入和删除
**以下操作均默认无哨兵节点**

### 遍历
               
*遍历是单链表一切操作的基础*

* 只使用一个指针，记录当前位置

>for(cp;cp!=NULL;cp=cp->next)

在for循环中对cp进行操作

* 使用两个指针，分别记录当前位置与前驱位置，用于插入、删除等操作
>for(cp=HL,ap=NULL;cp!=NULL;ap=cp,cp=cp->next)

在for循环中对cp进行操作

while语句为：
```
while(cp){
/*操作*/
ap=cp;
cp->next;
```
### 查找

在遍历的基础上，每次遍历到一个节点就做一个标记，得出查找的算法

### 插入
#### 只用一个指针
1. 对表头节点或空表插入，情况相同。
```
newp->next=HL;
HL=newp;
```
2. 对中间节点（包括表尾节点）插入必须使用两个指针
3. 在单链表最后添加一个节点
```
newp->next=NULL;
//tail的位置对遍历算法进行一些修改得到
tail->next=newp;
```
#### 两个指针ap,cp
>ap=NULL;cp=HL;
对单链表进行查找操作，找到后插入一个节点，查找算法：
```
while(cp!=NULL){
/*查找操作,做标记*/
if(seek_success) break;
else {ap=cp;cp=cp->next;
}
```
while循环过后，cp指向目标节点，ap前驱节点。
此时ap,cp的情况有多种情况，需要进行判断
>if(ap=NULL) //空表或目标节点是表头节点

>if(ap!=NULL&&cp!=NULL) //目标节点是中间节点

>if(ap!=NULL&&cp==NULL) //目标节点在表位节点的后面（ＮＵＬＬ）

ap==NULL还可进一步判断，但由于插入操作对于表头和空表的情况相同，因此不做判断.判断条件如下:

----------------------------------------------------------------------------------------------------------------------

>if(ap==NULL&&cp==NULL)　//空表

>if(ap==NULL&&cp!=NULL) 或 cp==HL//表头节点

----------------------------------------------------------------------------------------------------------------------


1. 对空表或者表头插入(ap=NULL)
```
/*情况与只使用一个指针相同*/
newp->next;
HL=newp;
```
2.对中间节点插入(ap==NULL&&cp=NULL) 
```
/*ap,newp,cp指向的节点按顺序链接*/
ap->next=newp;
newp->next=cp
```

3.向表尾添加(ap!=NULL&&cp=NULL)
```
ap->next=newp;
newp->next;
```
向表尾添加节点的元素与向中间节点插入节点并无不同.

因此，对于使用两个指针ap,cp 的情况，只分两种情况

*１．(ap==NULL)向空表或表头插入；*

*２．else向中间节点或者表尾后的ＮＵＬＬ插入。*


**哨兵**

链表中添加哨兵节点后，使头指针变成了哨兵的next指针，从而消除了头指针的特殊性，使得在任何位置的插入操作都与中间节点的操作相同。

### 删除
* 删除操操作步骤：
1. 查找到目标节点（两个指针）
2. **if(null) fail**
3. **tmp=cp**
3. **if(head) HL=HL->next**
4. **if(tail&&list_len==1) HL=NULL;if(tail&&list_len!=1) Do Nothing**
5. **if(middle) ap->next=cp->next;**
6. **free(tmp)**

* 一个指针只能删除表头或者表尾，方法同上
* 具体实现如下：
```
/*查找*/
ap=NULL;cp=HL
while(cp!=NULL){
/*查找操作，做标记*/
if(search_success) break;
ap=cp;
cp=cp->next
}
/*判断目标节点位置*/
//空表或目标节点不存在
if(cp==NULL)	
exit;
 //暂存cp
tmp=cp;	    
//目标节点为头结点
if(ap==NULL&&cp!=NULL) OR if(cp==HL)	
HL=HL->next;       			　
/*由于先处理头结点的情况，因此(tail&&list_len==1)的情况不会发生，
（tail&&list_len!=1)的情况又不需要处理，因此不需要对对尾节点进行任何操作*/
//对于中间节点和尾节点的操作一样
else ap->next=cp->next;	//中间节点用else即可
//释放目标节点
free(tmp)	
```
由上面分析知，删除操作只需考虑３种情况

*1. cp==NULL 空表或目标节点不存在*

*2. cp==HL 表头节点*

*3. else 中间节点（一般节点）*

**哨兵**

链表中添加哨兵节点后，使头指针变成了哨兵的next指针，从而消除了头指针的特殊性，使得在任何位置的删除操作都与中间节点的操作相同。
因此只需要判断*无哨兵*时的２，３点操作。

**删除链表删除到只剩一个节点时，ap,cp共同指向同一个节点(ap==cp)**
##　双链表