# 动态内存
## 对象在内存中的存储
程序中的对象存储在内存中,不同类型的变量存储在不同的类型的内存中.
* 静态内存:保存具有static性质的对象(局部static对象,全局对象,类中的static成员).程序运行时一直存在.
* 栈内存:保存局部对象.仅当当定义的程序块运行时存在;
* 自由空间(堆):保存动态分配的对象.生存期由程序决定.

## 动态内存的管理
动态内存的管理通过运算符**new**和**delete**完成.
* new:在动态内存中为对象分配内存空间并返回一个指向该对象的指针;
* delete:接受一个指向动态对象的指针,销毁对象并释放对象占用的内存空间.

一旦在动态内存管理中,没有正确处理好分配空间和释放空间的关系,就会出现各种问题.因此,C++提供了**智能指针**来更安全地使用动态内存.C++中应尽量使用智能指针替代内置指针.
* 标准库提供了两种种智能指针(shared_ptr和unique_ptr)和一个伴随类(weak_ptr).

* 动态内存的操作都定义在头文件**memory**中

## 直接管理内存:new和delete(是否需要移动构造函数?)
new和delete用于自定义管理内存,自己直接管理内存的类**不能依赖于类对象拷贝、赋值和销毁操作的任何默认定义**.这意味着使用自己直接管理内存的类应该格外小心,并且需要自己定义拷贝构造函数、拷贝赋值运算符、析构函数.

### 使用new分配内存
* 默认情况下new动态分配的对象默认初始化.因此当分配内置类型对象时,对象的值将是未定义的;分配类类型的对象时,使用默认构造函数进行初始化.
```
int *p=new int; //p指向一个动态分配的、值未知的无名int对象.
```
* 可以使用直接初始化或列表初始化来动态分配对象.对于类类型对象直接初始化实际上是调用构造函数.
```
int *p1=new int(100); //动态分配一个值为100的无名int对象.
vector<int> *p2=new vector<int>{1,2,3,4,5,6} ;//动态分配一个值为{1,2,3,4,5,6}的无名vector<int>对象.
string *p3=new string(10,'s') ;//动态分配一个值为"ssssssssss"的无名string对象.
```
* 也可以对动态分配的对象进行值初始化.只需在类型名后面加一堆空括号.
```
string *p1=new string; //默认初始化为空string.
string *p2=new string(); //值初始化为空string.
int *p3=new int; //默认初始化;分配的int对象的值未定义.
int *p4=new int(); //值初始化为0.
```
* 当提供一个括号包围的初始化器时,就可以使用auto推断想要分配的对象的类型.
```
int val=11;
string str(5,'s');
auto p1=new auto(val); //p1自动推断为指向动态分配的int无名对象的指针.
auto p2=new auto(str); //p2自动推断为指向动态分配的string无名对象的指针.
auto p3=new auto{1,2,3}; //无法推断.括号内有多个初始化器.
```
* 分配const对象.定义了默认构造函数的类类型对象可以不显式初始化,编译器自动调用默认构造函数进行隐式初始化,其他类型的对象必须显式初始化.
```
const string *p1=new const string; //编译器调用string的默认构造函数隐式初始化.
const int *p2=new const int; //错误.
const int *p3=new const int(100); //正确,
```
### 内存耗尽时new的行为
* 当内存耗尽,new无法分配内存时,会抛出bad_alloc异常.
* 可以向new传递参数改变new的行为.比如:给new传递nothrow对象可以使new在分配失败时不抛出异常而返回空指针.
* nothrow和bad_alloc定义在头文件**new**中.
```
int *p1=new int(); //分配失败时抛出bad_alloc异常.
int *p2=new (nothrow) int(); //分配失败后返回空指针.
```
### 使用delete释放内存
* 传递给delete的指针必须指向**未释放的动态分配的内存**或**空指针**.
* 当delete一个并非动态分配的内存或是已经释放了的内存,**行为未定义**.
```
int i,*pi1=&i,*pi2=nullptr;
double *pd1=new double(33);
double *pd2=pd1; 
delete i; //错误.i不是指针.
delete pi1; //错误.pi1指向的不是动态分配的内存.
delete pd1; //正确.
delete pd2; //未定义.pd2指向的内存已经为释放.
delete pi2; //正确.delete一个空指针不产生任何变化.
```
* 为了避免**空悬指针**(指向一块曾保存对象但已释放掉的内存的指针),可以在delete后置指针为空.但这只提供了**有限的保护**.
```
int p1=new int();
int p2=p1; //p1、p2指向同一内存.
delete p1; //释放内存.
p1=nullptr; //置p1为空.
delete p2; //仍有从p2重复释放内存的风险.因此这只是提供了有限的保护.
```

### 注意事项
* 不要忘记delete内存;
* 不要使用已经销毁了的对象;
* 不要重复释放内存;
* 能用智能指针就别用内置指针.
## 智能指针
标准库提供了两种种智能指针(shared_ptr和unique_ptr)和一个伴随类(weak_ptr).来管理动态对象.
### shared_ptr类

### unique_ptr类

### weak_ptr类

## 动态数组

### 使用new和delete处理动态数组

### 使用allocator类处理动态数组
