## 容器类型别名
* forward_list之外的顺序容器都支持reverse_iterator

|类型别名|介绍|
|-|-|
|iterator|容器类型的迭代器类型|
|const_iterator|容器类型的常量迭代器类型|
|reverse_iterator|反向迭代器|
|const_reverse_iterator|常量反向迭代器|
|difference_type|容器的迭代器之差的类型|
|value_type|容器中元素的类型|
|size_type|能容纳此容器类型的最大可能容量的无符号整数类型|
|reference|容器的元素的引用类型|
|const_reference|容器的常量引用类型|
* iterator系列，通过begin(),end()系列成员函数获得.。
## 容器初始化
以下初始化方式所有容器均支持
|初始化|介绍|
|-|-|
|C c|c默认初始化。如果c为array，元素值未知|
|C c1(c2)|将c1初始化为c2的拷贝，c2类型必须完全相同|
|C c{lst}|列表初始化。对于array，lst内元素数目必须小于等于array容量|
|C c(b,e)|用两个迭代器表示范围内的值初始化容器。范围内的元素的值必须与C::value_type相容。**array不支持**。|
**以下初始化方式只有除*array*之外的*顺序容器*支持**

|||
|-|-|
|C seg(n)|**string不支持**.seq包含n个值初始化的元素，构造函数expilicit.
|C seq(n,t)|seq包含n个值为t的元素
注意:
1.C c1(c2)的初始化方式,c1、c2必须**完全相同**(类型相同、元素类型相同)
2;C c(b,e)的初始化方式,只需要b、e表示的范围内的元素的类型与容器元素类型**相容**
eg:标记
```
vector<int> vec1={1,2,3,4,5};
vector<double> vec2(vec1);   //正确
vector<double> vec3(vec1.cbegin(),vec1.cend()); //错误
```
3.array可以看做内置数组的改良版,各种行为与内置数组类似.比如:不能修改大小,创建时需要**指定大小**.
```
array<int,10> ia1; //
array<int,10> ia1={1,2,3,4,5,6,7,8,9,10};
array<int,10> ia2(ia2);
```
## 赋值与swap
* 赋值运算符将左边容器中的元素**替换**为右边容器中元素的**拷贝**.容器中原来的元素消失,因此赋值操作后,指向原来容器元素的指针、迭代器、引用全部**失效**.
* swap(除array、string外）**交换**两个容器中元素,即交换两个容器中的**内部数据结构**,,而不是替换元素的值.swap操作后,指向原来容器元素的指针、迭代器、引用仍**有效**,但此时元素已在另一个容器中了.
* array,string特殊.当对array、string进行swap操作后,容器两容器中的元素并不交换,元素的**值交换**.指针、迭代器、引用仍指向原来的元素（原来的位置），但值已改变.

**举例说明赋值与swap的特点**

        容器就是一个装满信件的袋子,信件就是容器的元素.现有容器A、B.
        A=B,相当与扔掉A袋子中的信件,然后将B袋子中的信件的复印件替代A袋子中的信件.
        swap(A,B).  当A,B不是array或string时,相当将A袋子里的信件放进B袋子,B袋子原来的信件放进A袋子.
                    当A,B是array或string时,相当与将A袋子中信件的内容擦去,对应地写上B袋子中信件的内容;B袋子的信件也将内容擦去,对应地写上原来A信件中的内容.

## 访问元素
1.通过**解引用迭代器**访问元素.
2.通过**容器定义的**访问操作访问元素
3.访问**不存在的元素**,行为**未定义**
* 除了**froward_list**不支持back()操作,其他顺序容器都支持front(),back()
* 只有支持**随机访问**的容器才支持下标操作

|访问操作|说明|
|-|-|
|c.back()|返回c的尾元素的引用|
|c.front()|返回c的首元素的引用|
|c[n]|返回c中下标为n的元素的引用|
|c.at[n]|返回c中下标为n 的元素的引用.当此元素不存在时,抛出out_of_range异常|
注意不要访问不存在的元素
eg:
```
list<int> lst;
vector<int> vec;
cout<<lst.front()<<endl; //错误,lst为空容器,没有首元素.
vec[0]=1; //错误.vec是空向量,没有下标为0的元素.
```
## 添加元素
1.添加元素用insert或emplace
2.forward_list不支持back相关的操作.string、vector不支持front相关的操作
3.forward_list有特殊的insert和emplace操作
4.array不能改变容量，因此不能添加元素
|插入操作|说明|
|-|-|
|c.push_back(t)|在尾部创建一个值为t创建的元素.返回void.|
|c.emplace_back(args)|在尾部用args创建元素.返回void.|
|c.push_front(t)|在头部创建一个值为t创建的元素.返回void.| |
|c.emplace_front(args)|在头部用args创建元素.返回void.|
|c.insert(p,t)|在迭代器p**之前**的位置插入参数表示范围内的值，返回指向**第一个**插入的元素的迭代器,若参数表示范围为0,返回p.|
|c.insert(p,n,t)|同上|
|c.insert(p,b,e)|同上|
|c.insert(p,il)|同上|
|c.emplace(p,args)|在迭代器p之前插入用args构造的元素,返回新添加元素的迭代器.|
|-----------------------------|---------------------------------------------------------------------------------------------|
|lst_insert_after(p,t)|在迭代器p**之后**的位置插入参数表示范围内的值,返回**最后一个插入**的元素的值.当参数表示范围为0时,返回p;p是尾后迭代器时,行为**未定义**.|
|lst_insert_after(p,n,t)|同上|
|lst.insert_after(p,b,e)|同上|
|lst.insert(p,il)|同上|
|lst.emplace(p,args)|同上|
* 可以利用insert操作的返回值进行连续的插入.
eg:
```
vector<string> message;
vector<string>::iterator iter=message.begin();
string word;
for(cin>>word)
    iter=message.insert(iter,word) //insert操作返回第一个插入的元素的迭代器,然后再在第一个插入的元素之前插入元素. 相当与message.push_front(word).当然,vector不支持push_front操作.
```
* 某些容器类型不支持专门的在某个位置上的操作,并不意味着就不能在该位置插入.
eg:
```
//vector不支持push.front()操作,但可以用insert完成相同的功能,但是性能可能很差.其他容器类型也如此.
vector<string> vec;
vec.insert(vec.begin(),"Yes");
```
## 删除元素
1.删除部分元素用eras(),清空容器clear()
2.array不能改变容量，因此不支持删除操作
3.forward_list不支持back相关的操作.string、vector不支持front相关的操作
4.forward_list有特殊的erase操作
|删除操作|说明|
|-|-|
|c.clear()|清空容器，返回void.|
|c.pop_front()|删除首元素，返回void.|
c.pop_back()|删除尾元素，返回void.|
|c.erase(p)|删除迭代器p指向的元素，返回指向被删除元素**后面元素**的迭代器.若p是尾后迭代器,行为**未定义**|
|c.erase(b,e)|删除b,e迭代器对表示范围内的元素,返回指向最后一个被删除元素后面元素的迭代器.若e为尾后迭代器,反馈尾后迭代器.|
|-------------------------|--------------------------------------------------------------------------------------------------|
|lst.erase_after(p)|删除迭代器**p指向位置后面**的元素,返回指向被删除元素**后面元素**的迭代器.|
|lst.erase_after(b,e)|删除b,e迭代器对表示的范围内的元素,返回最后一个被删除元素**后面元素**的迭代器.|
* 某些容器不支持专门的删除首尾元素的操作,但是可以用erase实现.
eg:
```
//vector不支持pop.front()操作,但可以用erase完成相同的功能,但是性能可能很差.其他容器类型也如此.
vector<int> vec={1,2,3,4};
vec.pop_front(); //错误.vector不支持push)front().
vec.erase(vec.begin()); //正确
```
* 可以利用erase返回值连续删除元素
eg:
###留着,再补

## 大小和修改容量
|操作|说明|
|-|-|
|c.size()||
|c.maxsize()||
|c.empty()||
|------------|--------|
|resize(n)||
|resize(n,t)||
|-------------|--------|
|c.capacity||
|c.reserve(n)||
|c.shrink_to_fit()||

## 容器关系运算
1.所有容器类型都支持==、!=操作
2.顺序容器都支持>、<、>=、<=操作
3.== 、!= 运算符实际标记上通过元素的== 运算符完成.
4.<、>、<=、>=实际上通过元素的<运算符完成.
5.由3,4知，当元素不支持== 或<操作时,容器类型就无法完成相应的关系运算符运算.


## 迭代器


